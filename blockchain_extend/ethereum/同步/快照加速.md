# geth：快照加速

这是一个系列的第1部分，任何人都可以问关于Geth的问题，我将尝试每周用一篇小文章回答投票率最高的问题。本周投票率最高的问题是：您能否分享FlatDB结构与传统结构的区别？

## 以太坊状态

在深入研究加速结构之前，让我们先回顾一下以太坊称之为状态的内容，以及它当前在不同抽象级别的存储方式。

以太坊维护两种不同类型的状态：帐户集；以及每个合约帐户的一组存储插槽。从纯抽象的角度来看，这两个都是简单的键/值映射。帐户集将地址映射到其当前值、余额等。单个合约的存储区域将合约定义和使用的任意键映射到任意值。
不幸的是，虽然将这些键值对存储为平面数据非常有效，但验证它们的正确性在计算上变得非常困难。每次修改时，我们都需要从头开始散列所有数据。
我们不必一直对整个数据集进行散列，而可以将其拆分为连续的小块，并在顶部构建一棵树！原始有用的数据将在叶子中，每个内部节点将是它下面所有内容的散列。这将允许我们在修改某些内容时只重新计算对数散列数。这个数据结构实际上有一个名字，它是著名的Merkle树。
不幸的是，我们在计算复杂性方面仍然有点欠缺。上面的Merkle树布局在合并对现有数据的修改方面非常有效，但是插入和删除会改变块边界，并使所有计算的哈希无效。
我们可以使用键本身将数据组织成基于公共前缀的树格式，而不是盲目地将数据集分块！这样，插入或删除不会移动所有节点，而只会更改从根到叶的对数路径。这种数据结构称为Patricia树。
将这两种思想结合起来——Patricia树的树布局和Merkle树的哈希算法——最终得到Merkle Patricia树，这是以太坊中用于表示状态的实际数据结构。保证修改、插入、删除和验证的对数复杂性！一个小小的额外功能是在插入之前对键进行散列，以平衡尝试。

## 以太坊中的状态存储
上面的描述解释了以太坊将其状态存储在Merkle Patricia树中的原因。唉，尽管期望的操作速度很快，但每个选择都是一种权衡。对数更新和对数验证的成本是每个密钥的对数读取和对数存储。这是因为每个内部trie节点都需要单独保存到磁盘。
目前我没有帐户trie深度的准确数字，但大约一年前，我们将深度饱和为7。这意味着，每个trie操作（例如读平衡、写nonce）至少涉及7-8个内部节点，因此将至少进行7-8次持久数据库访问。LevelDB还将其数据组织为最多7个级别，因此有一个额外的乘数。最终的结果是，单个状态的访问预计会扩大到25-50个随机磁盘访问。将其与所有状态读写相乘，一个块中的所有事务都会接触，得到一个可怕的数字。
[当然，所有客户端实现都会尽最大努力将此开销降至最低。Geth使用大内存区域缓存trie节点；并且还使用内存中的修剪来避免写入磁盘节点，这些节点在几个块之后就会被删除。但这是另一篇博文。]
尽管这些数字非常可怕，但这些都是操作以太坊节点以及能够随时对所有状态进行加密验证的成本。但我们能做得更好吗？

## 并非所有访问都是平等创建的
以太坊的状态依赖于加密证明。如果我们想保留验证所有数据的能力，就没有办法绕过磁盘放大。也就是说，我们可以——而且确实——相信我们已经验证过的数据。
每次我们从磁盘中取出每个状态项时，都没有必要对其进行验证和重新验证。Merkle-Patricia树对于写入来说是必不可少的，但是对于读取来说是一种开销。我们无法摆脱它，也无法将其瘦身；但这并不意味着我们必须在任何地方都使用它。
以太坊节点在几个不同的位置访问状态：
导入新块时，EVM代码执行会执行或多或少平衡的状态读写次数。然而，拒绝服务块可能会进行比写入多得多的读取。
当节点操作符检索状态（例如eth_调用和family）时，EVM代码执行只执行读取（它也可以写入，但这些读取在最后被丢弃，并且不会持久化）。
当一个节点正在同步时，它正在请求远程节点的状态，这些远程节点需要将其挖掘出来并通过网络为其提供服务。
基于上述访问模式，如果我们能够短路读取以不命中状态trie，那么大量节点操作将显著加快。它甚至可能启用一些新的访问模式（如状态迭代），这在以前是非常昂贵的。
当然，总有一个权衡。如果不去掉trie，任何新的加速结构都会带来额外的开销。问题是额外的开销是否提供了足够的价值来保证它？

## 追本溯源
我们建造了这棵神奇的Merkle Patricia树来解决我们所有的问题，现在我们想绕过它进行阅读。我们应该使用什么样的加速结构使读取速度再次加快？如果我们不需要trie，我们就不需要引入任何复杂性。我们可以一直追溯到起源。
正如本文开头提到的，以太坊状态理论上理想的数据存储是一个简单的键值存储（单独用于帐户和每个合约）。但是，如果没有Merkle Patricia树的约束，“没有什么”可以阻止我们实际实现理想的解决方案！
不久前，Geth引入了快照加速结构（默认情况下未启用）。快照是给定块上以太坊状态的完整视图。抽象实现方面，它是所有帐户和存储插槽的转储，由一个平面键值存储表示。
每当我们希望访问帐户或存储插槽时，我们只需支付1 LevelDB lookup，而不是按照trie支付7-8。从理论上讲，更新快照也很简单，在处理一个块之后，我们会对每个更新的插槽进行1次额外的LevelDB写入。
快照实质上减少了从O（日志n）到O（1）（乘以LevelDB开销）的读取，但代价是将写入从O（日志n）增加到O（1+log n）（乘以LevelDB开销），并将磁盘存储从O（n日志n）增加到O（n+n日志n）。

## 魔鬼在细节中
维护以太坊状态的可用快照有其复杂性。只要块一个接一个地出现，总是在最后一个块的基础上构建，那么将更改合并到快照中的天真方法就会奏效。但是，如果有一个迷你reorg（即使是一个块），我们就有麻烦了，因为没有撤销。持久写入是平面数据表示的单向操作。更糟糕的是，不可能访问较旧的状态（例如，对于某些DApp为3个旧块，对于快速/快照同步为64+）。
为了克服这一限制，Geth的快照由两个实体组成：一个持久磁盘层，它是较旧块（例如HEAD-128）的完整快照；以及一个内存中差异层的树，这些层将写操作收集在顶部。
每当处理一个新的块时，我们不会将写操作直接合并到磁盘层，而只是用更改创建一个新的内存差异层。如果有足够多的内存差异层堆积在顶部，则底部的层开始合并在一起，并最终推送到磁盘上。每当要读取一个状态项时，我们都从最上面的diff层开始，一直向后走，直到找到它或到达磁盘。
这种数据表示非常强大，因为它解决了许多问题。由于内存中的diff层被组装成一棵树，因此小于128个块的reorg可以简单地拾取属于父块的diff层，并从父块向前构建。需要旧状态的DAPP和远程同步器可以访问128个最新状态。成本确实增加了128个映射查找，但128个内存中查找要比LevelDB放大4-5倍的8个磁盘读取快几个数量级。
当然，有很多很多的陷阱和警告。在不涉及太多细节的情况下，可以快速列出以下要点：
自毁（和删除）是特殊的野兽，因为它们需要短路不同层下降。
如果存在比持久磁盘层更深的reorg，则需要完全丢弃并重新生成快照。这个很贵。
关闭时，需要将内存中的差异层持久化到日志中并加载备份，否则重新启动时快照将变得无用。
将最底层的diff层用作累加器，并且仅当它超过某些内存使用量时才刷新到磁盘。这允许跨块对相同插槽进行重复写入。
为磁盘层分配一个读缓存，这样反复访问同一个旧插槽不会导致磁盘命中。
使用内存中差异层中的累积bloom过滤器快速检测项目是否有机会出现在差异中，或者是否可以立即转到磁盘。
密钥不是原始数据（帐户地址、存储密钥），而是这些数据的散列，确保快照具有与Merkle Patricia树相同的迭代顺序。
生成持久磁盘层所需的时间远远超过状态尝试的修剪窗口，因此即使生成器也需要动态地遵循该链。

## 好的，坏的，丑陋的
Geth的快照加速结构将状态读取复杂性降低了大约一个数量级。这意味着基于读取的DoS将更难实现一个数量级；eth_调用的速度要快一个数量级（如果不受CPU限制的话）。
快照还支持最新块的快速状态迭代。这实际上是构建快照的主要原因，因为它允许创建新的快照同步算法。这是一篇全新的博客文章，但林克比的最新基准是：
Rinkeby快照同步
当然，权衡总是存在的。初始同步完成后，在mainnet上构建初始快照需要9-10个小时（之后会实时维护），并且需要额外15+GB的磁盘空间。
至于丑陋的部分？嗯，我们花了6个多月的时间才对快照的发布有足够的信心，但即使现在它还处于--snapshot标志之后，围绕内存使用和崩溃恢复仍需要进行调整和完善。
总而言之，我们为这一进步感到自豪。这是一个疯狂的工作量，这是一个巨大的黑暗中实施一切，并希望它会工作。有趣的是，snap-sync（leaf-sync）的第一个版本是在2.5年前编写的，从那时起就被阻止了，因为我们缺乏必要的加速来饱和它。
后记
希望你喜欢《询问Geth》的第一篇帖子。我花了大约两倍的时间来完成它，比我的目标，但我觉得这个话题值得额外的时间。下周见。
[注：我故意没有将询问/投票网站链接到这篇文章中，因为我确信这是一件临时的事情，我不想为后代留下断开的链接；将来也不会有人买了这个名字，并主持一些恶意的活动。你可以在我的推特帖子中找到它。]

参考：[Snapshot acceleration](https://blog.ethereum.org/2020/07/17/ask-about-geth-snapshot-acceleration/)


